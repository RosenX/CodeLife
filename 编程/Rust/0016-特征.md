# 特征

特征类似java中的接口，具备什么样的特征，就可以支持什么样的行为

## 定义与使用

```rust

pub trait Summary {
    fn summarize(&self) -> String;
}
pub struct Post {
    pub title: String, // 标题
    pub author: String, // 作者
    pub content: String, // 内容
}

impl Summary for Post { //
    fn summarize(&self) -> String {
        format!("文章{}, 作者是{}", self.title, self.author)
    }
}

pub struct Weibo {
    pub username: String,
    pub content: String
}

impl Summary for Weibo {
    fn summarize(&self) -> String {
        format!("{}发表了微博{}", self.username, self.content)
    }
}

fn main() {
    let post = Post{title: "Rust语言简介".to_string(),author: "Sunface".to_string(), content: "Rust棒极了!".to_string()};
    let weibo = Weibo{username: "sunface".to_string(),content: "好像微博没Tweet好用".to_string()};
    
    println!("{}", post.summarize());
    println!("{}", weibo.summarize());
}
```

- trait: 关键字
- Summary: 特征名
- summarize: 方法，不定义具体怎么实现，在具体类定义的时候在会具体定义实现方法
- 关于特征实现与定义的位置，有一条非常重要的原则（孤儿规则）：如果你想要为类型 A 实现特征 T，那么 A 或者 T 至少有一个是在当前作用域中定义的！确保你不会改别人代码，别人也不会改你代码。
- pub：别人可以在他们的包中使用该特征
- 如果你要使用一个特征的方法，那么你需要引入该特征到当前的作用域中

```rust
pub trait Summary {
    fn summarize(&self) -> String {
        String::from("(Read more...)") //默认实现
    }
}

pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author()) // 默认实现可以调用特征中其他方法，即使没有实现
    }
}

impl Summary for Post {}

impl Summary for Weibo {
    fn summarize(&self) -> String {
        format!("{}发表了微博{}", self.username, self.content)
    }
}
```

## 使用特征作为函数参数

```rust
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

fn main() {
    let post = Post{title: "Rust语言简介".to_string(),author: "Sunface".to_string(), content: "Rust棒极了!".to_string()};
    let weibo = Weibo{username: "sunface".to_string(),content: "好像微博没Tweet好用".to_string()};

    notify(&post);
    notify(&weibo);
}
```

- `&impl Summay`，只要实现Summary特征的类型都可以作为参数，类似于多态
- 接收特征的方法里只能调用特征的方法

## 特征约束

```rust
pub fn notify(item: &impl Summary) { //语法糖
    println!("Breaking news! {}", item.summarize());
}

pub fn notify<T: Summary>(item: &T) { // 完整形式，函数参数必须实现了Summary特征
    println!("Breaking news! {}", item.summarize());
}

pub fn notify(item: &(impl Summary + Display)) {} // 多重约束
pub fn notify<T: Summary + Display>(item: &T) {} // 多重约束

fn some_function<T: Display + Clone, U: Clone + Debug>(t: &T, u: &U) -> i32 {}
fn some_function<T, U>(t: &T, u: &U) -> i32 // where约束，简化签名形式
    where T: Display + Clone,
          U: Clone + Debug {}
```

### 有条件的实现方法

```rust
use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}
impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self {
            x,
            y,
        }
    }
}
impl<T: Display + PartialOrd> Pair<T> { //只为具有Display和PartialOrd特征的类型实现cmp_display方法
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}
```

### 有条件实现特征

```rust
impl<T: Display> ToString for T { //只为具有Display特征的类型实现ToString特征
    // --snip--
}

```

## 函数返回中的impl trait

```rust
fn returns_summarizable() -> impl Summary { //返回一个具有Summary特征的类型
    Weibo {
        username: String::from("sunface"),
        content: String::from(
            "m1 max太厉害了，电脑再也不会卡",
        )
    }
}

fn returns_summarizable(switch: bool) -> impl Summary { // 报错，只能返回一个类型
    if switch {
        Post {
            title: String::from(
                "Penguins win the Stanley Cup Championship!",
            ),
            author: String::from("Iceburgh"),
            content: String::from(
                "The Pittsburgh Penguins once again are the best \
                 hockey team in the NHL.",
            ),
        }
    } else {
        Weibo {
            username: String::from("horse_ebooks"),
            content: String::from(
                "of course, as you probably already know, people",
            ),
        }
    }
}
```


## 通过derive派生特征

通过derive可以自动派生特征的默认实现代码

- `#[derive(Debug)]`可以派生Debug特征，可以使用`println!("{:?}",s)`打印结构体信息